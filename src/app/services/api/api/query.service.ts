/**
 * TWCore Diagnostics Api
 * TWCore diagnostics api
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ApplicationsLevels } from '../model/applicationsLevels';
import { NodeStatusItem } from '../model/nodeStatusItem';
import { PagedListNodeLogItem } from '../model/pagedListNodeLogItem';
import { PagedListNodeStatusItem } from '../model/pagedListNodeStatusItem';
import { PagedListNodeTraceItem } from '../model/pagedListNodeTraceItem';
import { SerializedObject } from '../model/serializedObject';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { environment } from '../../../../environments/environment';

@Injectable()
export class QueryService {

    protected basePath = environment.apiUrl;
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     *
     *
     * @param environment
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ApplicationsLevels>>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ApplicationsLevels>>>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ApplicationsLevels>>>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsApplicationsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ApplicationsLevels>>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/applications`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param application
     * @param level
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeLogItem>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }
        if (level === null || level === undefined) {
            throw new Error('Required parameter level was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeLogItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/${encodeURIComponent(String(application))}/${encodeURIComponent(String(level))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param group
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeLogItem>;
    public apiQueryByEnvironmentLogsGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsGroupByGroupByApplicationGet.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling apiQueryByEnvironmentLogsGroupByGroupByApplicationGet.');
        }
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling apiQueryByEnvironmentLogsGroupByGroupByApplicationGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeLogItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/group/${encodeURIComponent(String(group))}/${encodeURIComponent(String(application))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param search
     * @param level
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsLevelByLevelBySearchGet(environment: string, search: string, level: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeLogItem>;
    public apiQueryByEnvironmentLogsLevelByLevelBySearchGet(environment: string, search: string, level: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsLevelByLevelBySearchGet(environment: string, search: string, level: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsLevelByLevelBySearchGet(environment: string, search: string, level: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsLevelByLevelBySearchGet.');
        }
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling apiQueryByEnvironmentLogsLevelByLevelBySearchGet.');
        }
        if (level === null || level === undefined) {
            throw new Error('Required parameter level was null or undefined when calling apiQueryByEnvironmentLogsLevelByLevelBySearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeLogItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/level/${encodeURIComponent(String(level))}/${encodeURIComponent(String(search))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param search
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeLogItem>;
    public apiQueryByEnvironmentLogsSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsSearchBySearchGet.');
        }
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling apiQueryByEnvironmentLogsSearchBySearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeLogItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/search/${encodeURIComponent(String(search))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param machine
     * @param application
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeStatusItem>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeStatusItem>>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeStatusItem>>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentStatusCurrentGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (machine !== undefined) {
            queryParameters = queryParameters.set('machine', <any>machine);
        }
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<NodeStatusItem>>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/status/current`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param machine
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeStatusItem>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeStatusItem>>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeStatusItem>>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentStatusGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (machine !== undefined) {
            queryParameters = queryParameters.set('machine', <any>machine);
        }
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeStatusItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/status`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param group
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeTraceItem>;
    public apiQueryByEnvironmentTracesGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeTraceItem>>;
    public apiQueryByEnvironmentTracesGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeTraceItem>>;
    public apiQueryByEnvironmentTracesGroupByGroupByApplicationGet(environment: string, group: string, application: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesGroupByGroupByApplicationGet.');
        }
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling apiQueryByEnvironmentTracesGroupByGroupByApplicationGet.');
        }
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling apiQueryByEnvironmentTracesGroupByGroupByApplicationGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeTraceItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/group/${encodeURIComponent(String(group))}/${encodeURIComponent(String(application))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesObjectByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiQueryByEnvironmentTracesObjectByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiQueryByEnvironmentTracesObjectByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiQueryByEnvironmentTracesObjectByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesObjectByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesObjectByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/object/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<SerializedObject>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SerializedObject>>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SerializedObject>>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesRawByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesRawByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<SerializedObject>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/raw/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param search
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeTraceItem>;
    public apiQueryByEnvironmentTracesSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeTraceItem>>;
    public apiQueryByEnvironmentTracesSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeTraceItem>>;
    public apiQueryByEnvironmentTracesSearchBySearchGet(environment: string, search: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesSearchBySearchGet.');
        }
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling apiQueryByEnvironmentTracesSearchBySearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeTraceItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/search/${encodeURIComponent(String(search))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryGet(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public apiQueryGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public apiQueryGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public apiQueryGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/api/query`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

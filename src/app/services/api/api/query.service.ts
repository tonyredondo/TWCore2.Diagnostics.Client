/**
 * TWCore Diagnostics Api
 * TWCore diagnostics api
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { LogSummary } from '../model/logSummary';
import { NodeLogItem } from '../model/nodeLogItem';
import { NodeStatusItem } from '../model/nodeStatusItem';
import { NodeTraceItem } from '../model/nodeTraceItem';
import { PagedListNodeLogItem } from '../model/pagedListNodeLogItem';
import { PagedListNodeStatusItem } from '../model/pagedListNodeStatusItem';
import { PagedListTraceResult } from '../model/pagedListTraceResult';
import { SearchResults } from '../model/searchResults';
import { SerializedObject } from '../model/serializedObject';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { environment } from '../../../../environments/environment';


@Injectable()
export class QueryService {

    protected basePath = environment.apiUrl;
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     *
     *
     * @param environment
     * @param fromDate
     * @param toDate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, fromDate?: Date, toDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<LogSummary>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, fromDate?: Date, toDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogSummary>>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, fromDate?: Date, toDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogSummary>>;
    public apiQueryByEnvironmentLogsApplicationsGet(environment: string, fromDate?: Date, toDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsApplicationsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<LogSummary>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/applications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param application
     * @param level
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeLogItem>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeLogItem>>;
    public apiQueryByEnvironmentLogsByApplicationByLevelGet(environment: string, application: string, level: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }
        if (application === null || application === undefined) {
            throw new Error('Required parameter application was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }
        if (level === null || level === undefined) {
            throw new Error('Required parameter level was null or undefined when calling apiQueryByEnvironmentLogsByApplicationByLevelGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeLogItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/${encodeURIComponent(String(application))}/${encodeURIComponent(String(level))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param searchTerm
     * @param fromDate
     * @param toDate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentLogsSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeLogItem>>;
    public apiQueryByEnvironmentLogsSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeLogItem>>>;
    public apiQueryByEnvironmentLogsSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeLogItem>>>;
    public apiQueryByEnvironmentLogsSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentLogsSearchBySearchTermGet.');
        }
        if (searchTerm === null || searchTerm === undefined) {
            throw new Error('Required parameter searchTerm was null or undefined when calling apiQueryByEnvironmentLogsSearchBySearchTermGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<NodeLogItem>>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/logs/search/${encodeURIComponent(String(searchTerm))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param searchTerm
     * @param fromDate
     * @param toDate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<SearchResults>;
    public apiQueryByEnvironmentSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchResults>>;
    public apiQueryByEnvironmentSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchResults>>;
    public apiQueryByEnvironmentSearchBySearchTermGet(environment: string, searchTerm: string, fromDate?: Date, toDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentSearchBySearchTermGet.');
        }
        if (searchTerm === null || searchTerm === undefined) {
            throw new Error('Required parameter searchTerm was null or undefined when calling apiQueryByEnvironmentSearchBySearchTermGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<SearchResults>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/search/${encodeURIComponent(String(searchTerm))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param machine
     * @param application
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeStatusItem>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeStatusItem>>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeStatusItem>>>;
    public apiQueryByEnvironmentStatusCurrentGet(environment: string, machine?: string, application?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentStatusCurrentGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (machine !== undefined) {
            queryParameters = queryParameters.set('machine', <any>machine);
        }
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<NodeStatusItem>>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/status/current`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param machine
     * @param application
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListNodeStatusItem>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListNodeStatusItem>>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListNodeStatusItem>>;
    public apiQueryByEnvironmentStatusGet(environment: string, machine?: string, application?: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentStatusGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (machine !== undefined) {
            queryParameters = queryParameters.set('machine', <any>machine);
        }
        if (application !== undefined) {
            queryParameters = queryParameters.set('application', <any>application);
        }
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListNodeStatusItem>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/status`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param groupName
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesByGroupNameGet(environment: string, groupName: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeTraceItem>>;
    public apiQueryByEnvironmentTracesByGroupNameGet(environment: string, groupName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeTraceItem>>>;
    public apiQueryByEnvironmentTracesByGroupNameGet(environment: string, groupName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeTraceItem>>>;
    public apiQueryByEnvironmentTracesByGroupNameGet(environment: string, groupName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesByGroupNameGet.');
        }
        if (groupName === null || groupName === undefined) {
            throw new Error('Required parameter groupName was null or undefined when calling apiQueryByEnvironmentTracesByGroupNameGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<NodeTraceItem>>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/${encodeURIComponent(String(groupName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param fromDate
     * @param toDate
     * @param page
     * @param pageSize
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesGet(environment: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<PagedListTraceResult>;
    public apiQueryByEnvironmentTracesGet(environment: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedListTraceResult>>;
    public apiQueryByEnvironmentTracesGet(environment: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedListTraceResult>>;
    public apiQueryByEnvironmentTracesGet(environment: string, fromDate?: Date, toDate?: Date, page?: number, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate.toISOString());
        }
        if (toDate !== undefined) {
            queryParameters = queryParameters.set('toDate', <any>toDate.toISOString());
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (pageSize !== undefined) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<PagedListTraceResult>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesJsonByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public apiQueryByEnvironmentTracesJsonByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public apiQueryByEnvironmentTracesJsonByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiQueryByEnvironmentTracesJsonByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesJsonByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesJsonByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/json/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<SerializedObject>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SerializedObject>>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SerializedObject>>;
    public apiQueryByEnvironmentTracesRawByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesRawByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesRawByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<SerializedObject>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/raw/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesXmlByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public apiQueryByEnvironmentTracesXmlByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public apiQueryByEnvironmentTracesXmlByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiQueryByEnvironmentTracesXmlByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesXmlByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesXmlByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/xml/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param environment
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryByEnvironmentTracesTxtByIdGet(environment: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public apiQueryByEnvironmentTracesTxtByIdGet(environment: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public apiQueryByEnvironmentTracesTxtByIdGet(environment: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiQueryByEnvironmentTracesTxtByIdGet(environment: string, id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (environment === null || environment === undefined) {
            throw new Error('Required parameter environment was null or undefined when calling apiQueryByEnvironmentTracesXmlByIdGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling apiQueryByEnvironmentTracesXmlByIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/api/query/${encodeURIComponent(String(environment))}/traces/txt/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiQueryGet(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public apiQueryGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public apiQueryGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public apiQueryGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/binary-formatter',
            'application/n-binary',
            'application/pw-binary',
            'application/w-binary'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/api/query`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
